package examples

import (
	"os"

	"github.com/01-edu/z01"
)

// Example 1
// Напишите программу, которая печатает своё название, и введенный аргумент, используя PrintRune.
// Write a program that prints its name and input argument using PrintRune.

func PrintProgramNameWithProgArgs() {
	args := os.Args // не забывай os.Args просто слайс строк
	for _, arg := range args {
		// нужно добавить пробел в конце каждого арг чтобы они печатались раздельно, иначе будет каша
		arg += " "

		// если тебе нужно чтобы каждый аргумент печатался с новой строки
		// тебе нужно в конце каждого аргумента добавить спец. символ переноса строки - \n
		arg += "\n"

		// нам нужно сначала преобразовать строку в слайс рун, чтобы использовать PrintRune,
		// она принимает только руны, и только по одной
		rArg := []rune(arg)

		// и так как PrintRune принимает только по одной руне, нам нужно вызывать его внутри
		// другого цикла и передавать по руне
		for _, r := range rArg {
			z01.PrintRune(r)
		}
	}
}

// Example 2
// Напишите программу, которая печатает результат сложения переданного аргумента

func PrintCalcSumArgs() {
	// не забывай os.Args это слайс строк, а нам нужно сложить все получение аргументы как чисел
	args := os.Args[1:]
	totalSum := 0

	for _, arg := range args {
		// и так как тебе нельзя будет использовать стандартную библиотеку,
		//и нам могут передать не только цифры, специально, поэтому проверяем
		for _, a := range arg {
			if a == ' ' { // если есть пробел для нас это ничего = 0
				a = 0
			}
			if a < '0' || a > '9' { // проверка на цифры соответственно, если нет просто прерываем, можно не реагировать
				return // важно, ретурн без возвращаемого значения прерывает функцию
			}
			totalSum += int(a - '0') // преобразуем символ в цифру, вычитая код символа '0', и суммируем
		}

		// важно
		// хочу тебе заранее сказать, что есть способ преобразования символов в инт которая заменяет вес свитч
		// и кроме этого если можно было бы использовать стандартные либы
		// то код можно сократить на одну строчку! позже напомни, чтобы я рассказал
		// пример с стд либ
		//argSum, err := strconv.Atoi(arg)
		//if err != nil {
		//	return
		//}
		//totalSum += argSum

	}

	println("total sum: ", totalSum)

	z01.PrintRune(rune(totalSum + '0')) // преобразуем цифру в руну, добавляя код символа '0'
	z01.PrintRune('\n')
}

// Example 3
// Напишите программу, которая печатает комбинации все возможных цифр (base 10).
// Длина комбинации зависеть от введенного аргумента, и используя PrintRune

func PrintCombN() {
	k := 0 // длина последовательности комбинации

	// проверяем чтобы длина os.Args была 2 (0 - наз. программы, 1 - длина последовательности комбинации)
	if len(os.Args) == 2 {
		if len(os.Args[1]) == 1 {
			arg := os.Args[1]     // получаем аргумент определяющий длину последовательности комбинации
			k = int(arg[0] - '0') // преобразуем символ в цифру, вычитая код символа '0'
		} else {
			return
		}
	}

	// проверяем что переданный аргумент был цифрой, и не был пустотой
	if k != ' ' && k > '0' && k < '9' {
		return
	}

	// вызываем combine, и присваиваем результат
	combinations := combine(k)
	//fmt.Println(combinations)
	// так как результат двухмерный слайс - [][]int, нам нужно перебрать его -> []int -> int
	for _, comb := range combinations {
		for _, n := range comb {
			r := rune(n + '0') // приводим тип int к rune, добавляя код символа '0'
			z01.PrintRune(r)
		}
		z01.PrintRune(' ')
	}
	z01.PrintRune('\n')
}

// Важно!!!
// Чувствую что такая задача тебе попадет...
// Прочти, реализация возможных комбинаций не сложная. Я описал этапы алгоритма. Он очень простой.

// 1. Создаётся массив длиной k и начинается с индекса 0.
// 2. Увеличить значение по текущему индексу i.
// 3. Если значение текущего индекса i превысило предел n, вернуться к
//  предыдущему индексу i-- и продолжить приращение для следующих комбинаций.
// 4. Если достигнут последний индекс k - 1, добавить копию текущего массива arr,
//  так как это завершенная комбинация.
// 5. Если значение по текущему индексу не превысило предела n и последний индекс k - 1
//  не был достигнут, перейти к следующему индексу i++ и скопировать значение из предыдущего
// индекса arr[i] = arr[i - 1], затем продолжите с шага 2.

func combine(k int) (res [][]int) {
	arr := make([]int, k)
	i := 0 // index
	n := 9 // base

	for i >= 0 {
		arr[i]++

		if arr[i] > n {
			i--
		} else if i == k-1 {
			res = append(res, append([]int{}, arr...))
		} else {
			i++
			arr[i] = arr[i-1]
		}
	}

	return res
}
